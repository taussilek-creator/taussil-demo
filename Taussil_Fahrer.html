
      getDoc(doc(db,"orders", oid)).then(ds=>{
        if(!ds.exists()) return;
        const o=ds.data()||{};
        const s=String(o.status||'').toLowerCase();
        if(s==='abgebrochen' || s==='geliefert') return;
        showIncoming({id:oid, o});
      }).catch(()=>{});
    }
  });
}

/* ===== Incoming popup + ØªÙ†Ø¨ÙŠÙ‡ ØµÙˆØªÙŠ Ù…ÙØµØ­Ù‘Ø­ ===== */
function showIncoming({id,o}){
  inText.textContent = `${o.restaurant?.name||'â€”'} Â· ${Array.isArray(o.platform)?o.platform.join(' / '):(o.platform||'â€”')}`;
  incoming.classList.add("show");
  // ðŸ”” ÙØ¹Ù‘Ù„ Ø§Ù„ØµÙˆØª Ø¹Ù†Ø¯ Ø¸Ù‡ÙˆØ± Ø§Ù„Ù€incoming
  startIncomingSound(id);
  inAccept.onclick = async (e)=>{ e.preventDefault(); await acceptAssigned(id); stopIncomingAlert(); closeIncoming(); };
  inReject.onclick = async (e)=>{ e.preventDefault(); await rejectAssigned(id); stopIncomingAlert(); closeIncoming(); };
}
function closeIncoming(){ incoming.classList.remove("show"); /* Ø£ÙˆÙ‚Ù Ø§Ù„ØµÙˆØª Ø¹Ù†Ø¯ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ */ stopIncomingAlert(); }

/* === Audio Autoplay Unlock + Beep Scheduler (FIX) === */
let beepTimer=null;
let audioUnlocked=false;
function unlockAudioOnce(){
  if(audioUnlocked) return;
  audioUnlocked = true;
  try{
    if(newOrderSound){
      newOrderSound.muted = false;
      newOrderSound.volume = 1;
      // Ù†Ø¨Ø¶Ø© Ø³Ø±ÙŠØ¹Ø© Ù„ÙÙƒ Ø§Ù„Ù‚ÙÙ„
      newOrderSound.play().then(()=>newOrderSound.pause()).catch(()=>{});
    }
  }catch(_){}
}
// ÙÙƒ Ø§Ù„Ù‚ÙÙ„ Ø¨Ø¹Ø¯ Ø£ÙŠ ØªÙØ§Ø¹Ù„ Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©
['pointerdown','touchstart','keydown','focus'].forEach(evt=>{
  window.addEventListener(evt, unlockAudioOnce, { once:true, capture:true });
});

function startIncomingSound(scope=''){
  if(!newOrderSound) return;
  // Ù„Ø§ Ù†Ø³Ù…Ø­ Ø¨ØªØ¹Ø¯Ø¯ Ø§Ù„Ù…Ø¤Ù‚ØªØ§Øª
  if(beepTimer){ clearInterval(beepTimer); beepTimer=null; }
  const play = ()=>{
    try{
      newOrderSound.muted = false; newOrderSound.volume = 1;
      newOrderSound.currentTime = 0;
      newOrderSound.play().catch(()=>{ /* Ù‚Ø¯ ÙŠØ±ÙØ¶ Ù‚Ø¨Ù„ unlockØ› Ù„Ø§ Ù…Ø´ÙƒÙ„Ø© */ });
    }catch(_){}
  };
  play();
  // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ ÙƒÙ„ 30 Ø«Ø§Ù†ÙŠØ© Ø¥Ø°Ø§ Ù…Ø§ ØªÙØ§Ø¹Ù„ Ø§Ù„Ø³Ø§Ø¦Ù‚
  beepTimer = setInterval(play, 30000);
}
function stopIncomingAlert(){
  if(beepTimer){ clearInterval(beepTimer); beepTimer=null; }
  try{ newOrderSound?.pause(); }catch(_){}
}

/* ===== Multi helper ===== */
async function updateAllItemsStatus(id, status) {
  const orderRef = doc(db, "orders", id);
  const orderSnap = await getDoc(orderRef);
  if (!orderSnap.exists()) return;

  const updates = {};
  const arr = Array.isArray(orderSnap.data().items) ? orderSnap.data().items : [];
  arr.forEach((_, idx) => {
    updates[`items.${idx}.status`] = status;
  });
  updates.updatedAt = serverTimestamp();

  await updateDoc(orderRef, updates);
}

/* ===== Start / Accept / Reject ===== */
async function safeSetStatusToUnterwegs(id){
  try{
    const snap=await getDoc(doc(db,"orders", id));
    const o=snap.exists()? (snap.data()||{}) : {};
    const s=String(o.status||'').toLowerCase();
    if(!(s==='angenommen' || s==='unterwegs')){ await patchOrder(id, { status:"Angenommen" }); }
    await patchOrder(id, { status:"Unterwegs" });
    toast("Unterwegs");
  }catch(_){ toast("Fehler beim Start"); }
}
async function acceptAssigned(id){ await patchOrder(id, { status:"Angenommen" }); toast("Angenommen"); }
async function rejectAssigned(id){ await patchOrder(id, { status:"Abgebrochen" }); toast("Abgebrochen"); }

/* ===== Detail sheet ===== */
// === Price helpers & refs ===
const md_price_value = document.getElementById('md_price_value');
const md_price_edit  = document.getElementById('md_price_edit');

const priceModal   = document.getElementById('priceModal');
const price_close  = document.getElementById('price_close');
const price_cancel = document.getElementById('price_cancel');
const price_save   = document.getElementById('price_save');
const price_input  = document.getElementById('price_input');

let priceEditOrderId = null;
let priceBusy = false;

function formatEUR(val){
  const n = Number(val||0);
  try{ return new Intl.NumberFormat('de-DE',{style:'currency',currency:'EUR'}).format(n); }
  catch{ return n.toFixed(2)+' â‚¬'; }
}
function parseEUR(raw){
  if(!raw) return null;
  const cleaned = String(raw).replace(/[^\d,.\-]/g,'').trim().replace(',', '.');
  const num = Number(cleaned);
  if(!isFinite(num) || num < 0) return null;
  if(num > 500) return null;
  return Math.round(num * 100) / 100;
}
function canEditPrice(o){
  const assigned = (o?.driver?.id === uid);
  const s = String(o?.status||'').toLowerCase();
  const allowed = (s==='bearbeitung' || s==='unterwegs' || s==='angenommen' || s==='assigned' || s==='zugewiesen');
  return assigned && allowed;
}
function openPriceModal(prefillEUR){
  price_input.value = (typeof prefillEUR === 'number' ? prefillEUR.toFixed(2).replace('.', ',') : '');
  priceModal.classList.add('show');
  setTimeout(()=>{ price_input?.focus(); price_input?.select(); }, 0);
}
function closePriceModal(){ priceModal.classList.remove('show'); }
price_close?.addEventListener('click', closePriceModal);
price_cancel?.addEventListener('click', closePriceModal);
priceModal?.addEventListener('click', (e)=>{ if(e.target===priceModal) closePriceModal(); });

async function savePriceEUR(orderId, newPriceEUR){
  if(priceBusy) return;
  priceBusy = true; price_save.disabled = true;
  try{
    const refDoc = doc(db, 'orders', orderId);
    await runTransaction(db, async (tx) => {
      const snap = await tx.get(refDoc);
      if(!snap.exists()) throw new Error('Order not found');
      const data = snap.data() || {};
      if(!canEditPrice(data)) throw new Error('Status/Berechtigung');

      const prevEUR  = Number(data.price||0) || 0;
      const prevCent = Number.isFinite(data.price_cents)? data.price_cents : Math.round(prevEUR*100);

      tx.update(refDoc, {
        price: newPriceEUR,
        price_cents: Math.round(newPriceEUR*100),
        price_prev_cents: prevCent,
        price_change_count: increment(1),
        price_updated_by: 'driver',
        price_updated_at: serverTimestamp(),
        updatedAt: serverTimestamp(),
      });
    });
    md_price_value.textContent = formatEUR(newPriceEUR);
    toast('âœ” Preis gespeichert');
    closePriceModal();
  }catch(e){
    const msg = String(e?.message||e);
    if(msg.includes('Status/Berechtigung')) toast('Status erlaubt keine Ã„nderung / Keine Berechtigung');
    else toast('Fehler beim Speichern');
  }finally{
    priceBusy = false; price_save.disabled = false;
  }
}

// Ø±Ø¨Ø· Ø²Ø± Ø§Ù„Ø­ÙØ¸ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©
price_save?.addEventListener('click', async ()=>{
  const eur = parseEUR(price_input.value);
  if(eur===null){ toast('UngÃ¼ltiger Betrag (0â€“500 â‚¬)'); return; }
  if(!priceEditOrderId){ toast('Kein Auftrag'); return; }
  await savePriceEUR(priceEditOrderId, eur);
});

async function openDetail(id){
  const snap=await getDoc(doc(db,"orders", id)); if(!snap.exists()) return;
  const o=snap.data()||{};
  md_id.textContent=id;
  md_status.textContent=mapStatusLabel(o.status||"â€”");
  md_platform.textContent=Array.isArray(o.platform)?o.platform.join(" / "):(o.platform||"â€”");
  md_rest.textContent=o.restaurant?.name||"â€”";
  const addr=(o.restaurant?.addressText || o.restaurant?.address_text || "").trim();
  md_addr.textContent=addr || 'â€”';
  md_qty.textContent=Number(o.qty||0)||0;
  md_pickup.textContent=o.pickupTime || "â€”";
  md_title.textContent=o.restaurant?.name||"Auftrag";
  const priceEUR = Number(o.price||0) || 0;
md_price_value.textContent = formatEUR(priceEUR);
md_price_edit.disabled = !canEditPrice(o);
md_price_edit.title = md_price_edit.disabled ? 'Keine Berechtigung / Ø§Ù„Ø­Ø§Ù„Ø© Ù„Ø§ ØªØ³Ù…Ø­' : 'Preis bearbeiten';
priceEditOrderId = id;
md_price_edit.onclick = (e)=>{
  e.preventDefault();
  if(md_price_edit.disabled) return;
  openPriceModal(priceEUR);
};

  md.classList.add("show");
  md_start.onclick=async (e)=>{
    e.preventDefault();
    if(!addr){ toast('Restaurant-Adresse fehlt'); return; }
    window.open(makeNavUrl(addr), '_blank', 'noopener,noreferrer');
    await safeSetStatusToUnterwegs(id);
  };
  md_done.onclick = async (e)=>{
    e.preventDefault();
    await finalizeOrderWithFee(id);
    md.classList.remove("show");
  };
  md_nav.onclick  = (e)=>{
    e.preventDefault();
    if(!addr){ toast('Restaurant-Adresse fehlt'); return; }
    window.open(makeNavUrl(addr), '_blank', 'noopener,noreferrer');
  };
}
mdClose.addEventListener("click", ()=> md.classList.remove("show"));
md.addEventListener("click",(e)=>{ if(e.target===md) md.classList.remove("show"); });

/* ===== Patch order helper ===== */
// Ù„Ùˆ Ø£Ø±Ø¯Øª Ø§Ø³ØªØ®Ø¯Ø§Ù… deliveryFee Ø±Ø³Ù…ÙŠÙ‹Ø§: Ø§Ø³Ù…Ø­ Ø¨Ù‡ ÙÙŠ Ø§Ù„Ù€ Rules (Ø£Ù†Ø¸Ø± Ø£Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø©)
const PREFER_DELIVERY_FEE_FIELD = true;
async function patchOrder(id, fields){
  const allowed = {};
  if('status'      in fields) allowed.status      = fields.status;
  if('price'       in fields) allowed.price       = Number(fields.price);
  if('deliveryFee' in fields) allowed.deliveryFee = Number(fields.deliveryFee);
  if('etmTargetMs' in fields) allowed.etmTargetMs = fields.etmTargetMs;
  if('ETM_Target'  in fields) allowed.ETM_Target  = fields.ETM_Target;
  allowed.updatedAt = serverTimestamp();
  const refDoc=doc(db,"orders", id);
  try{ await updateDoc(refDoc, allowed); }
  catch{ await setDoc(refDoc, allowed, { merge:true }); }
}

/* ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø±Ø³ÙˆÙ… Ù…Ø¹ Fallback Ù„ÙŠØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠØ© */
async function writeFeeOnly(id, fee){
  await patchOrder(id, { status:"Geliefert", deliveryFee: fee });
  return { field:'deliveryFee', fee };
}


/* Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ø¹Ù†Ø¯ Ø§Ù„ØªØ³Ù„ÙŠÙ…: route â†’ km â†’ Betrag â†’ Fee â†’ ØªØ­Ø¯ÙŠØ« */
/* ===== PATCH: finalizeOrderWithFee (single + multi progressive) ===== */
function __lsKeyBaseTaken(orderId){ return `multi:baseTaken:${orderId}`; }
function __getBaseTaken(orderId){ try{ return localStorage.getItem(__lsKeyBaseTaken(orderId))==='1'; }catch(_){ return false; } }
function __setBaseTaken(orderId){ try{ localStorage.setItem(__lsKeyBaseTaken(orderId),'1'); }catch(_){ } }

/* Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ø¹Ù†Ø¯ Ø§Ù„ØªØ³Ù„ÙŠÙ…: route â†’ km â†’ Betrag â†’ Fee â†’ ØªØ­Ø¯ÙŠØ« (Single + Multi) */
async function finalizeOrderWithFee(id, idx = null) {
  const ref = doc(db, "orders", id);
  const ds = await getDoc(ref);

  if (!ds.exists()) {
    toast("Auftrag nicht gefunden");
    return;
  }

  const o = ds.data() || {};
  const items = Array.isArray(o.items) ? o.items : [];
  const isMulti = items.length > 0;
  const isValidIdx = Number.isInteger(idx) && idx >= 0 && idx < items.length;

  // âœ… Ø·Ù„Ø¨ Ù…ÙØ±Ø¯ Ø£Ùˆ idx ØºÙŠØ± ØµØ§Ù„Ø­ â†’ ØªØ³Ù„ÙŠÙ… ÙƒØ§Ù…Ù„
  if (!isMulti || !isValidIdx) {
    const km = await computeLegKmForOrder(o);
    const betrag = getOrderAmount(o);
    const fee = calcFeeSingleOrMulti(o, betrag, km);
    await writeFeeOnly(id, fee);

    const drop = getDropAddr(o);
    if (drop) setLastDestFromText(drop);
    else if (lastLL) setLastDestFromLL(lastLL);

    toast(`Geliefert Â· ${km.toFixed(2)} km Â· LiefergebÃ¼hr ${fee.toFixed(2)}â‚¬`);
    return;
  }

  // âœ… ØªØ³Ù„ÙŠÙ… Ø¹Ù†ØµØ± ÙˆØ§Ø­Ø¯ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ù…Ø±ÙƒÙ‘Ø¨
  const item = items[idx];

  if (!item || (item.status || "").toLowerCase() === "geliefert") {
    toast("Teilauftrag bereits geliefert oder ungÃ¼ltig");
    return;
  }

  const legKm = await computeLegKmForItem(o, idx); // ØªØ­Ø³Ø¨ Ø§Ù„Ù…Ø³Ø§ÙØ© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¹Ù†ØµØ± ÙÙ‚Ø·
  item.status = "Geliefert";
  item.km = legKm;

  // Ø³Ù„Ø³Ù„Ø© Ø§Ù„ØªØ³Ù„ÙŠÙ… chainKM
  let chainKm = Array.isArray(o.items)
    ? o.items.reduce((a, b) => a + (b.km || 0), 0)
    : legKm;

  const allDelivered = o.items.every(it => (it.status || "").toLowerCase() === "geliefert");

  let fee = 0;
  if (allDelivered) {
    const betrag = getOrderAmount(o);
    fee = calcFeeSingleOrMulti(o, betrag, chainKm);
    o.status = "Geliefert";
  }

  o.items[idx] = item;
  o.chainKm = chainKm;
  if (fee) o.deliveryFee = fee;

  await updateDoc(ref, o);

  const drop = item.drop || getDropAddr(item);
  if (drop) setLastDestFromText(drop);
  else if (lastLL) setLastDestFromLL(lastLL);

  toast(`Teilauftrag geliefert Â· ${legKm.toFixed(2)} km`);
}


/* ===== /PATCH finalizeOrderWithFee ===== */


/* ===== Auth gate ===== */
onAuthStateChanged(auth, async (user)=>{
  // Ø§Ù…Ù†Ø¹ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¥Ù„Ø§ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ (regInFlight)
  if (user && sessionStorage.getItem(SESSION_OK) !== '1' && !regInFlight) {
    await signOut(auth).catch(()=>{});
    authModal.style.display='flex'; appRoot.style.display='none';
    return;
  }
  if(!user){
    uid=null;
    appRoot.style.display='none'; authModal.style.display='flex';
    detachOrders(); stopPresence(); stopIncomingAlert();
	stopMedianBG();

    switchPane(lastAuthTab==='register' ? 'register' : 'login');
    return;
  }
  uid = user.uid;

  // ØªØ­Ù‚Ù‚ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø©
  approved=false;
  try{
    const ds=await getDoc(doc(db,'users',uid));
    if(ds.exists()){
      const u=ds.data()||{};
      approved=(u.approved===true && u.role==='driver');
    }
  }catch(_){}

  authModal.style.display='none'; appRoot.style.display='block';
  attachOrders();
});

/* ===== Network dot ===== */
function setNet(on){ netDot.classList.toggle("on", on); netDot.classList.toggle("off", !on); }
setNet(navigator.onLine);
window.addEventListener("online", ()=>setNet(true));
window.addEventListener("offline", ()=>setNet(false));

/* ===== Init ===== */
document.addEventListener('DOMContentLoaded', ()=>{
  authModal.style.display='flex';
  switchPane(lastAuthTab==='register' ? 'register' : 'login');
});


</script>

</body>
</html>

