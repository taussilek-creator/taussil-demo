
      getDoc(doc(db,"orders", oid)).then(ds=>{
        if(!ds.exists()) return;
        const o=ds.data()||{};
        const s=String(o.status||'').toLowerCase();
        if(s==='abgebrochen' || s==='geliefert') return;
        showIncoming({id:oid, o});
      }).catch(()=>{});
    }
  });
}

/* ===== Incoming popup + تنبيه صوتي مُصحّح ===== */
function showIncoming({id,o}){
  inText.textContent = `${o.restaurant?.name||'—'} · ${Array.isArray(o.platform)?o.platform.join(' / '):(o.platform||'—')}`;
  incoming.classList.add("show");
  // 🔔 فعّل الصوت عند ظهور الـincoming
  startIncomingSound(id);
  inAccept.onclick = async (e)=>{ e.preventDefault(); await acceptAssigned(id); stopIncomingAlert(); closeIncoming(); };
  inReject.onclick = async (e)=>{ e.preventDefault(); await rejectAssigned(id); stopIncomingAlert(); closeIncoming(); };
}
function closeIncoming(){ incoming.classList.remove("show"); /* أوقف الصوت عند الإغلاق */ stopIncomingAlert(); }

/* === Audio Autoplay Unlock + Beep Scheduler (FIX) === */
let beepTimer=null;
let audioUnlocked=false;
function unlockAudioOnce(){
  if(audioUnlocked) return;
  audioUnlocked = true;
  try{
    if(newOrderSound){
      newOrderSound.muted = false;
      newOrderSound.volume = 1;
      // نبضة سريعة لفك القفل
      newOrderSound.play().then(()=>newOrderSound.pause()).catch(()=>{});
    }
  }catch(_){}
}
// فك القفل بعد أي تفاعل لمرة واحدة
['pointerdown','touchstart','keydown','focus'].forEach(evt=>{
  window.addEventListener(evt, unlockAudioOnce, { once:true, capture:true });
});

function startIncomingSound(scope=''){
  if(!newOrderSound) return;
  // لا نسمح بتعدد المؤقتات
  if(beepTimer){ clearInterval(beepTimer); beepTimer=null; }
  const play = ()=>{
    try{
      newOrderSound.muted = false; newOrderSound.volume = 1;
      newOrderSound.currentTime = 0;
      newOrderSound.play().catch(()=>{ /* قد يرفض قبل unlock؛ لا مشكلة */ });
    }catch(_){}
  };
  play();
  // إعادة التنبيه كل 30 ثانية إذا ما تفاعل السائق
  beepTimer = setInterval(play, 30000);
}
function stopIncomingAlert(){
  if(beepTimer){ clearInterval(beepTimer); beepTimer=null; }
  try{ newOrderSound?.pause(); }catch(_){}
}

/* ===== Multi helper ===== */
async function updateAllItemsStatus(id, status) {
  const orderRef = doc(db, "orders", id);
  const orderSnap = await getDoc(orderRef);
  if (!orderSnap.exists()) return;

  const updates = {};
  const arr = Array.isArray(orderSnap.data().items) ? orderSnap.data().items : [];
  arr.forEach((_, idx) => {
    updates[`items.${idx}.status`] = status;
  });
  updates.updatedAt = serverTimestamp();

  await updateDoc(orderRef, updates);
}

/* ===== Start / Accept / Reject ===== */
async function safeSetStatusToUnterwegs(id){
  try{
    const snap=await getDoc(doc(db,"orders", id));
    const o=snap.exists()? (snap.data()||{}) : {};
    const s=String(o.status||'').toLowerCase();
    if(!(s==='angenommen' || s==='unterwegs')){ await patchOrder(id, { status:"Angenommen" }); }
    await patchOrder(id, { status:"Unterwegs" });
    toast("Unterwegs");
  }catch(_){ toast("Fehler beim Start"); }
}
async function acceptAssigned(id){ await patchOrder(id, { status:"Angenommen" }); toast("Angenommen"); }
async function rejectAssigned(id){ await patchOrder(id, { status:"Abgebrochen" }); toast("Abgebrochen"); }

/* ===== Detail sheet ===== */
// === Price helpers & refs ===
const md_price_value = document.getElementById('md_price_value');
const md_price_edit  = document.getElementById('md_price_edit');

const priceModal   = document.getElementById('priceModal');
const price_close  = document.getElementById('price_close');
const price_cancel = document.getElementById('price_cancel');
const price_save   = document.getElementById('price_save');
const price_input  = document.getElementById('price_input');

let priceEditOrderId = null;
let priceBusy = false;

function formatEUR(val){
  const n = Number(val||0);
  try{ return new Intl.NumberFormat('de-DE',{style:'currency',currency:'EUR'}).format(n); }
  catch{ return n.toFixed(2)+' €'; }
}
function parseEUR(raw){
  if(!raw) return null;
  const cleaned = String(raw).replace(/[^\d,.\-]/g,'').trim().replace(',', '.');
  const num = Number(cleaned);
  if(!isFinite(num) || num < 0) return null;
  if(num > 500) return null;
  return Math.round(num * 100) / 100;
}
function canEditPrice(o){
  const assigned = (o?.driver?.id === uid);
  const s = String(o?.status||'').toLowerCase();
  const allowed = (s==='bearbeitung' || s==='unterwegs' || s==='angenommen' || s==='assigned' || s==='zugewiesen');
  return assigned && allowed;
}
function openPriceModal(prefillEUR){
  price_input.value = (typeof prefillEUR === 'number' ? prefillEUR.toFixed(2).replace('.', ',') : '');
  priceModal.classList.add('show');
  setTimeout(()=>{ price_input?.focus(); price_input?.select(); }, 0);
}
function closePriceModal(){ priceModal.classList.remove('show'); }
price_close?.addEventListener('click', closePriceModal);
price_cancel?.addEventListener('click', closePriceModal);
priceModal?.addEventListener('click', (e)=>{ if(e.target===priceModal) closePriceModal(); });

async function savePriceEUR(orderId, newPriceEUR){
  if(priceBusy) return;
  priceBusy = true; price_save.disabled = true;
  try{
    const refDoc = doc(db, 'orders', orderId);
    await runTransaction(db, async (tx) => {
      const snap = await tx.get(refDoc);
      if(!snap.exists()) throw new Error('Order not found');
      const data = snap.data() || {};
      if(!canEditPrice(data)) throw new Error('Status/Berechtigung');

      const prevEUR  = Number(data.price||0) || 0;
      const prevCent = Number.isFinite(data.price_cents)? data.price_cents : Math.round(prevEUR*100);

      tx.update(refDoc, {
        price: newPriceEUR,
        price_cents: Math.round(newPriceEUR*100),
        price_prev_cents: prevCent,
        price_change_count: increment(1),
        price_updated_by: 'driver',
        price_updated_at: serverTimestamp(),
        updatedAt: serverTimestamp(),
      });
    });
    md_price_value.textContent = formatEUR(newPriceEUR);
    toast('✔ Preis gespeichert');
    closePriceModal();
  }catch(e){
    const msg = String(e?.message||e);
    if(msg.includes('Status/Berechtigung')) toast('Status erlaubt keine Änderung / Keine Berechtigung');
    else toast('Fehler beim Speichern');
  }finally{
    priceBusy = false; price_save.disabled = false;
  }
}

// ربط زر الحفظ مرة واحدة
price_save?.addEventListener('click', async ()=>{
  const eur = parseEUR(price_input.value);
  if(eur===null){ toast('Ungültiger Betrag (0–500 €)'); return; }
  if(!priceEditOrderId){ toast('Kein Auftrag'); return; }
  await savePriceEUR(priceEditOrderId, eur);
});

async function openDetail(id){
  const snap=await getDoc(doc(db,"orders", id)); if(!snap.exists()) return;
  const o=snap.data()||{};
  md_id.textContent=id;
  md_status.textContent=mapStatusLabel(o.status||"—");
  md_platform.textContent=Array.isArray(o.platform)?o.platform.join(" / "):(o.platform||"—");
  md_rest.textContent=o.restaurant?.name||"—";
  const addr=(o.restaurant?.addressText || o.restaurant?.address_text || "").trim();
  md_addr.textContent=addr || '—';
  md_qty.textContent=Number(o.qty||0)||0;
  md_pickup.textContent=o.pickupTime || "—";
  md_title.textContent=o.restaurant?.name||"Auftrag";
  const priceEUR = Number(o.price||0) || 0;
md_price_value.textContent = formatEUR(priceEUR);
md_price_edit.disabled = !canEditPrice(o);
md_price_edit.title = md_price_edit.disabled ? 'Keine Berechtigung / الحالة لا تسمح' : 'Preis bearbeiten';
priceEditOrderId = id;
md_price_edit.onclick = (e)=>{
  e.preventDefault();
  if(md_price_edit.disabled) return;
  openPriceModal(priceEUR);
};

  md.classList.add("show");
  md_start.onclick=async (e)=>{
    e.preventDefault();
    if(!addr){ toast('Restaurant-Adresse fehlt'); return; }
    window.open(makeNavUrl(addr), '_blank', 'noopener,noreferrer');
    await safeSetStatusToUnterwegs(id);
  };
  md_done.onclick = async (e)=>{
    e.preventDefault();
    await finalizeOrderWithFee(id);
    md.classList.remove("show");
  };
  md_nav.onclick  = (e)=>{
    e.preventDefault();
    if(!addr){ toast('Restaurant-Adresse fehlt'); return; }
    window.open(makeNavUrl(addr), '_blank', 'noopener,noreferrer');
  };
}
mdClose.addEventListener("click", ()=> md.classList.remove("show"));
md.addEventListener("click",(e)=>{ if(e.target===md) md.classList.remove("show"); });

/* ===== Patch order helper ===== */
// لو أردت استخدام deliveryFee رسميًا: اسمح به في الـ Rules (أنظر أعلى الرسالة)
const PREFER_DELIVERY_FEE_FIELD = true;
async function patchOrder(id, fields){
  const allowed = {};
  if('status'      in fields) allowed.status      = fields.status;
  if('price'       in fields) allowed.price       = Number(fields.price);
  if('deliveryFee' in fields) allowed.deliveryFee = Number(fields.deliveryFee);
  if('etmTargetMs' in fields) allowed.etmTargetMs = fields.etmTargetMs;
  if('ETM_Target'  in fields) allowed.ETM_Target  = fields.ETM_Target;
  allowed.updatedAt = serverTimestamp();
  const refDoc=doc(db,"orders", id);
  try{ await updateDoc(refDoc, allowed); }
  catch{ await setDoc(refDoc, allowed, { merge:true }); }
}

/* كتابة الرسوم مع Fallback ليتوافق مع القواعد الحالية */
async function writeFeeOnly(id, fee){
  await patchOrder(id, { status:"Geliefert", deliveryFee: fee });
  return { field:'deliveryFee', fee };
}


/* العملية الكاملة عند التسليم: route → km → Betrag → Fee → تحديث */
/* ===== PATCH: finalizeOrderWithFee (single + multi progressive) ===== */
function __lsKeyBaseTaken(orderId){ return `multi:baseTaken:${orderId}`; }
function __getBaseTaken(orderId){ try{ return localStorage.getItem(__lsKeyBaseTaken(orderId))==='1'; }catch(_){ return false; } }
function __setBaseTaken(orderId){ try{ localStorage.setItem(__lsKeyBaseTaken(orderId),'1'); }catch(_){ } }

/* العملية الكاملة عند التسليم: route → km → Betrag → Fee → تحديث (Single + Multi) */
async function finalizeOrderWithFee(id, idx = null) {
  const ref = doc(db, "orders", id);
  const ds = await getDoc(ref);

  if (!ds.exists()) {
    toast("Auftrag nicht gefunden");
    return;
  }

  const o = ds.data() || {};
  const items = Array.isArray(o.items) ? o.items : [];
  const isMulti = items.length > 0;
  const isValidIdx = Number.isInteger(idx) && idx >= 0 && idx < items.length;

  // ✅ طلب مفرد أو idx غير صالح → تسليم كامل
  if (!isMulti || !isValidIdx) {
    const km = await computeLegKmForOrder(o);
    const betrag = getOrderAmount(o);
    const fee = calcFeeSingleOrMulti(o, betrag, km);
    await writeFeeOnly(id, fee);

    const drop = getDropAddr(o);
    if (drop) setLastDestFromText(drop);
    else if (lastLL) setLastDestFromLL(lastLL);

    toast(`Geliefert · ${km.toFixed(2)} km · Liefergebühr ${fee.toFixed(2)}€`);
    return;
  }

  // ✅ تسليم عنصر واحد داخل الطلب المركّب
  const item = items[idx];

  if (!item || (item.status || "").toLowerCase() === "geliefert") {
    toast("Teilauftrag bereits geliefert oder ungültig");
    return;
  }

  const legKm = await computeLegKmForItem(o, idx); // تحسب المسافة لهذا العنصر فقط
  item.status = "Geliefert";
  item.km = legKm;

  // سلسلة التسليم chainKM
  let chainKm = Array.isArray(o.items)
    ? o.items.reduce((a, b) => a + (b.km || 0), 0)
    : legKm;

  const allDelivered = o.items.every(it => (it.status || "").toLowerCase() === "geliefert");

  let fee = 0;
  if (allDelivered) {
    const betrag = getOrderAmount(o);
    fee = calcFeeSingleOrMulti(o, betrag, chainKm);
    o.status = "Geliefert";
  }

  o.items[idx] = item;
  o.chainKm = chainKm;
  if (fee) o.deliveryFee = fee;

  await updateDoc(ref, o);

  const drop = item.drop || getDropAddr(item);
  if (drop) setLastDestFromText(drop);
  else if (lastLL) setLastDestFromLL(lastLL);

  toast(`Teilauftrag geliefert · ${legKm.toFixed(2)} km`);
}


/* ===== /PATCH finalizeOrderWithFee ===== */


/* ===== Auth gate ===== */
onAuthStateChanged(auth, async (user)=>{
  // امنع الدخول التلقائي إلا أثناء التسجيل (regInFlight)
  if (user && sessionStorage.getItem(SESSION_OK) !== '1' && !regInFlight) {
    await signOut(auth).catch(()=>{});
    authModal.style.display='flex'; appRoot.style.display='none';
    return;
  }
  if(!user){
    uid=null;
    appRoot.style.display='none'; authModal.style.display='flex';
    detachOrders(); stopPresence(); stopIncomingAlert();
	stopMedianBG();

    switchPane(lastAuthTab==='register' ? 'register' : 'login');
    return;
  }
  uid = user.uid;

  // تحقق الموافقة
  approved=false;
  try{
    const ds=await getDoc(doc(db,'users',uid));
    if(ds.exists()){
      const u=ds.data()||{};
      approved=(u.approved===true && u.role==='driver');
    }
  }catch(_){}

  authModal.style.display='none'; appRoot.style.display='block';
  attachOrders();
});

/* ===== Network dot ===== */
function setNet(on){ netDot.classList.toggle("on", on); netDot.classList.toggle("off", !on); }
setNet(navigator.onLine);
window.addEventListener("online", ()=>setNet(true));
window.addEventListener("offline", ()=>setNet(false));

/* ===== Init ===== */
document.addEventListener('DOMContentLoaded', ()=>{
  authModal.style.display='flex';
  switchPane(lastAuthTab==='register' ? 'register' : 'login');
});


</script>

</body>
</html>

